在Java语言中，异常可以分为两类：Checked异常和Unchecked
异常。Unchecked异常包括java.lang.RuntimeException、
java.lang.Error以及它们的子类，其他异常都是Checked异常。所有异
常都最终继承自java.lang.Throwable。如果一个方法有可能导致
Checked异常抛出，则该方法要么需要捕获该异常并妥善处理，要
么必须把该异常列在自己的throws子句中，否则无法通过编译。
Unchecked异常没有这个限制。请注意，Java虚拟机规范并没有这个
规定，这只是Java语言的语法规则。

异常可以由Java虚拟机抛出，也可以由Java代码抛出。当Java虚
拟机在运行过程中遇到比较严重的问题时，会抛出java.lang.Error的
某个子类，如StackOverflowError、OutOfMemoryError等。程序一般
无法从这种异常里恢复，所以在代码中通常也不必关心这类异常。
一部分指令在执行过程中会导致Java虚拟机抛出
java.lang.RuntimeException的某个子类，如NullPointerException、
IndexOutOfBoundsException等。这类异常一般是代码中的bug导致
的，需要格外注意。在代码中抛出和处理异常是由athrow指令和方
法的异常处理表配合完成的

在Java 6之前，Oracle的Java编译器使用jsr、jsr_w和ret指令来实
现finally子句。

从字节码来看，异常对象似乎也只是普通的对象，通过new指令创建，然后调
用构造函数进行初始化。这是真的吗？如果查看java.lang.Exception
或RuntimeException的源代码就可以知道，这并不是真的。它们的
构造函数都调用了超类java.lang.Throwable的构造函数。Throwable
的构造函数又调用了fillInStackTrace（）方法记录Java虚拟机栈信息的
fillInStackTrace（）是用Java写的，必须借助另外一个本地方法
才能访问Java虚拟机栈，这个方法就是重载后的
fillInStackTrace（int）方法