本单元主要实现方法的调用和回调，同时讨论类和对象的初始化


从调用的角度来看，方法可以分为两类：静态方法（或者类方
法）和实例方法。静态方法通过类来调用，实例方法则通过对象引
用来调用。静态方法是静态绑定的，也就是说，最终调用的是哪个
方法在编译期就已经确定。实例方法则支持动态绑定，最终要调用
哪个方法可能要推迟到运行期才能知道，本章将详细讨论这一点。

从实现的角度来看，方法可以分为三类：没有实现（也就是抽
象方法）、用Java语言（或者JVM上的其他语言，如Groovy和Scala等）
实现和用本地语言（如C或者C++）实现。静态方法和抽象方法是互
斥的。在Java 8之前，接口只能包含抽象方法。为了实现Lambda表达
式，Java 8放宽了这一限制，在接口中也可以定义静态方法和默认
方法。本章不考虑接口的静态方法和默认方法，感兴趣的读者请阅
读Java虚拟机规范相关章节。在本书中，我们把Java等语言实现的
方法叫作Java方法。

首先，方法调用指令需要n+1个操作数，其中第1个操作数是
uint16索引，在字节码中紧跟在指令操作码的后面。通过这个索引，
可以从当前类的运行时常量池中找到一个方法符号引用，解析这个
符号引用就可以得到一个方法。注意，这个方法并不一定就是最终
要调用的那个方法，所以可能还需要一个查找过程才能找到最终要
调用的方法。剩下的n个操作数是要传递给被调用方法的参数，从
操作数栈中弹出。
如果要执行的是Java方法（而非本地方法），下一步是给这个方
法创建一个新的帧，并把它推到Java虚拟机栈顶。传递参数之后，
新的方法就可以开始执行了。

方法的最后一条指令是某个返回指令，这个指令负责把方法
的返回值推入前一帧的操作数栈顶，然后把当前帧从Java虚拟机栈
中弹出。

在定位到需要调用的方法之后，Java虚拟机要给这个方法创建
一个新的帧并把它推入Java虚拟机栈顶，然后传递参数。

再总结一下这4条指令的用途。invokestatic指令调用静态方法，很好理解。invokespecial指
令也比较好理解。首先，因为私有方法和构造函数不需要动态绑
定，所以invokespecial指令可以加快方法调用速度。其次，使用super
关键字调用超类中的方法不能使用invokevirtual指令，否则会陷入
无限循环。
那么为什么要单独定义invokeinterface指令呢？统一使用
invokevirtual指令不行吗？答案是，可以，但是可能会影响效率。这
两条指令的区别在于：当Java虚拟机通过invokevirtual调用方法时，
this引用指向某个类（或其子类）的实例。因为类的继承层次是固定
的，所以虚拟机可以使用一种叫作vtable（Virtual Method Table）的技
术加速方法查找。但是当通过invokeinterface指令调用接口方法时，
因为this引用可以指向任何实现了该接口的类的实例，所以无法使
用vtable技术。


比较指令可以分为两类：一类将比较结果推入操作数栈顶，一类根据比较结果跳转。比较指令是编译器实现
if-else、for、while等语句的基石，共有19条